import os
from PIL import Image
from numpy import array, uint8
import secrets
from cryptography.hazmat.primitives.ciphers.aead import AESGCM


class Hide:

    # Substitution while injecting data from image
    # Equivalent of decimal to zero padded numbers in base 4 
    _se = {0: '0000', 1: '0001', 2: '0002', 3: '0003', 4: '0010', 5: '0011', 6: '0012', 7: '0013', 8: '0020', 9: '0021', 10: '0022', 11: '0023', 12: '0030', 13: '0031', 14: '0032', 15: '0033', 16: '0100', 17: '0101', 18: '0102', 19: '0103', 20: '0110', 21: '0111', 22: '0112', 23: '0113', 24: '0120', 25: '0121', 26: '0122', 27: '0123', 28: '0130', 29: '0131', 30: '0132', 31: '0133', 32: '0200', 33: '0201', 34: '0202', 35: '0203', 36: '0210', 37: '0211', 38: '0212', 39: '0213', 40: '0220', 41: '0221', 42: '0222', 43: '0223', 44: '0230', 45: '0231', 46: '0232', 47: '0233', 48: '0300', 49: '0301', 50: '0302', 51: '0303', 52: '0310', 53: '0311', 54: '0312', 55: '0313', 56: '0320', 57: '0321', 58: '0322', 59: '0323', 60: '0330', 61: '0331', 62: '0332', 63: '0333', 64: '1000', 65: '1001', 66: '1002', 67: '1003', 68: '1010', 69: '1011', 70: '1012', 71: '1013', 72: '1020', 73: '1021', 74: '1022', 75: '1023', 76: '1030', 77: '1031', 78: '1032', 79: '1033', 80: '1100', 81: '1101', 82: '1102', 83: '1103', 84: '1110', 85: '1111', 86: '1112', 87: '1113', 88: '1120', 89: '1121', 90: '1122', 91: '1123', 92: '1130', 93: '1131', 94: '1132', 95: '1133', 96: '1200', 97: '1201', 98: '1202', 99: '1203', 100: '1210', 101: '1211', 102: '1212', 103: '1213', 104: '1220', 105: '1221', 106: '1222', 107: '1223', 108: '1230', 109: '1231', 110: '1232', 111: '1233', 112: '1300', 113: '1301', 114: '1302', 115: '1303', 116: '1310', 117: '1311', 118: '1312', 119: '1313', 120: '1320', 121: '1321', 122: '1322', 123: '1323', 124: '1330', 125: '1331', 126: '1332', 127: '1333', 128: '2000', 129: '2001', 130: '2002', 131: '2003',
          132: '2010', 133: '2011', 134: '2012', 135: '2013', 136: '2020', 137: '2021', 138: '2022', 139: '2023', 140: '2030', 141: '2031', 142: '2032', 143: '2033', 144: '2100', 145: '2101', 146: '2102', 147: '2103', 148: '2110', 149: '2111', 150: '2112', 151: '2113', 152: '2120', 153: '2121', 154: '2122', 155: '2123', 156: '2130', 157: '2131', 158: '2132', 159: '2133', 160: '2200', 161: '2201', 162: '2202', 163: '2203', 164: '2210', 165: '2211', 166: '2212', 167: '2213', 168: '2220', 169: '2221', 170: '2222', 171: '2223', 172: '2230', 173: '2231', 174: '2232', 175: '2233', 176: '2300', 177: '2301', 178: '2302', 179: '2303', 180: '2310', 181: '2311', 182: '2312', 183: '2313', 184: '2320', 185: '2321', 186: '2322', 187: '2323', 188: '2330', 189: '2331', 190: '2332', 191: '2333', 192: '3000', 193: '3001', 194: '3002', 195: '3003', 196: '3010', 197: '3011', 198: '3012', 199: '3013', 200: '3020', 201: '3021', 202: '3022', 203: '3023', 204: '3030', 205: '3031', 206: '3032', 207: '3033', 208: '3100', 209: '3101', 210: '3102', 211: '3103', 212: '3110', 213: '3111', 214: '3112', 215: '3113', 216: '3120', 217: '3121', 218: '3122', 219: '3123', 220: '3130', 221: '3131', 222: '3132', 223: '3133', 224: '3200', 225: '3201', 226: '3202', 227: '3203', 228: '3210', 229: '3211', 230: '3212', 231: '3213', 232: '3220', 233: '3221', 234: '3222', 235: '3223', 236: '3230', 237: '3231', 238: '3232', 239: '3233', 240: '3300', 241: '3301', 242: '3302', 243: '3303', 244: '3310', 245: '3311', 246: '3312', 247: '3313', 248: '3320', 249: '3321', 250: '3322', 251: '3323', 252: '3330', 253: '3331', 254: '3332', 255: '3333'}

    # Substitution while ejecting data from image
    # Equivalent of zero padded numbers in base 4 to decimal
    _sd = {'0000': 0, '0001': 1, '0002': 2, '0003': 3, '0010': 4, '0011': 5, '0012': 6, '0013': 7, '0020': 8, '0021': 9, '0022': 10, '0023': 11, '0030': 12, '0031': 13, '0032': 14, '0033': 15, '0100': 16, '0101': 17, '0102': 18, '0103': 19, '0110': 20, '0111': 21, '0112': 22, '0113': 23, '0120': 24, '0121': 25, '0122': 26, '0123': 27, '0130': 28, '0131': 29, '0132': 30, '0133': 31, '0200': 32, '0201': 33, '0202': 34, '0203': 35, '0210': 36, '0211': 37, '0212': 38, '0213': 39, '0220': 40, '0221': 41, '0222': 42, '0223': 43, '0230': 44, '0231': 45, '0232': 46, '0233': 47, '0300': 48, '0301': 49, '0302': 50, '0303': 51, '0310': 52, '0311': 53, '0312': 54, '0313': 55, '0320': 56, '0321': 57, '0322': 58, '0323': 59, '0330': 60, '0331': 61, '0332': 62, '0333': 63, '1000': 64, '1001': 65, '1002': 66, '1003': 67, '1010': 68, '1011': 69, '1012': 70, '1013': 71, '1020': 72, '1021': 73, '1022': 74, '1023': 75, '1030': 76, '1031': 77, '1032': 78, '1033': 79, '1100': 80, '1101': 81, '1102': 82, '1103': 83, '1110': 84, '1111': 85, '1112': 86, '1113': 87, '1120': 88, '1121': 89, '1122': 90, '1123': 91, '1130': 92, '1131': 93, '1132': 94, '1133': 95, '1200': 96, '1201': 97, '1202': 98, '1203': 99, '1210': 100, '1211': 101, '1212': 102, '1213': 103, '1220': 104, '1221': 105, '1222': 106, '1223': 107, '1230': 108, '1231': 109, '1232': 110, '1233': 111, '1300': 112, '1301': 113, '1302': 114, '1303': 115, '1310': 116, '1311': 117, '1312': 118, '1313': 119, '1320': 120, '1321': 121, '1322': 122, '1323': 123, '1330': 124, '1331': 125, '1332': 126, '1333': 127, '2000': 128, '2001': 129, '2002': 130, '2003': 131,
          '2010': 132, '2011': 133, '2012': 134, '2013': 135, '2020': 136, '2021': 137, '2022': 138, '2023': 139, '2030': 140, '2031': 141, '2032': 142, '2033': 143, '2100': 144, '2101': 145, '2102': 146, '2103': 147, '2110': 148, '2111': 149, '2112': 150, '2113': 151, '2120': 152, '2121': 153, '2122': 154, '2123': 155, '2130': 156, '2131': 157, '2132': 158, '2133': 159, '2200': 160, '2201': 161, '2202': 162, '2203': 163, '2210': 164, '2211': 165, '2212': 166, '2213': 167, '2220': 168, '2221': 169, '2222': 170, '2223': 171, '2230': 172, '2231': 173, '2232': 174, '2233': 175, '2300': 176, '2301': 177, '2302': 178, '2303': 179, '2310': 180, '2311': 181, '2312': 182, '2313': 183, '2320': 184, '2321': 185, '2322': 186, '2323': 187, '2330': 188, '2331': 189, '2332': 190, '2333': 191, '3000': 192, '3001': 193, '3002': 194, '3003': 195, '3010': 196, '3011': 197, '3012': 198, '3013': 199, '3020': 200, '3021': 201, '3022': 202, '3023': 203, '3030': 204, '3031': 205, '3032': 206, '3033': 207, '3100': 208, '3101': 209, '3102': 210, '3103': 211, '3110': 212, '3111': 213, '3112': 214, '3113': 215, '3120': 216, '3121': 217, '3122': 218, '3123': 219, '3130': 220, '3131': 221, '3132': 222, '3133': 223, '3200': 224, '3201': 225, '3202': 226, '3203': 227, '3210': 228, '3211': 229, '3212': 230, '3213': 231, '3220': 232, '3221': 233, '3222': 234, '3223': 235, '3230': 236, '3231': 237, '3232': 238, '3233': 239, '3300': 240, '3301': 241, '3302': 242, '3303': 243, '3310': 244, '3311': 245, '3312': 246, '3313': 247, '3320': 248, '3321': 249, '3322': 250, '3323': 251, '3330': 252, '3331': 253, '3332': 254, '3333': 255}

    # Dictionary to manipulate the units place of pixel value based on its output of modulo 4
    # This is the soul of this code
    _correction = {0: [0, 1, 2, 3], 1: [-1, 0, 1, 2], 2: [-2, -1, 0, 1], 3: [1, -2, -1, 0], 4: [0, -3, -2, -1],
                  5: [-1, -4, -3, -2], 6: [-2, 3, 0, 1], 7: [1, 2, -1, 0], 8: [0, 1, -2, -1], 9: [-1, 0, -3, -2]}

    # To encrypt data with AES GCM
    # Returns encrypted bytes
    def _encrypt_data(self, key, data):
        # encoding if data is string
        if isinstance(data, str):
            data = data.encode()
        nonce = secrets.token_bytes(12)
        token = nonce + AESGCM(key).encrypt(nonce, data, b"")
        return token

    # To decrypt data with AES GCM
    # Returns decrpyted bytes
    def _decrypt_data(self, key, data):
        token = AESGCM(key).decrypt(data[:12], data[12:], b"")
        return token

    # Converting all non ASCII text using utf-8 encoding
    def _encode_4(self, s):
        if not isinstance(s, int):
            t = ""
            s = s.encode()
            for i in s:
                t += self._se[i]
            return t
        else:
            return self._se[s]
    
    # Function to feed data into the image
    def inject(self, imgPath, outImgPath, key, text):
        img_raw = Image.open(os.path.abspath(imgPath))
        img = img_raw.load()
        try:
            alpha = img[0][3] != ""
        except:
            alpha = False

        if isinstance(text, (int, float)):
            text = str(text)
        text = self._encrypt_data(key, text)

        text = "".join(list(map(self._encode_4, list(text))))
        if len(text) >= img_raw.size[0]*img_raw.size[1]*3:
            return (False, "Data is larger than image")

        img_width = img_raw.size[0]
        for i in range(len(text)//3):
            y = i//img_width
            x = i % img_width
            pixel = img[x, y]
            r = pixel[0]+self._correction[pixel[0] % 10][int(text[3*i])]
            g = pixel[1]+self._correction[pixel[1] % 10][int(text[3*i+1])]
            b = pixel[2]+self._correction[pixel[2] % 10][int(text[3*i+2])]
            if alpha:
                img[x, y] = (r, g, b, pixel[3])
            else:
                img[x, y] = (r, g, b, 255)

        i = len(text)//3
        y = i//img_width
        x = i % img_width
        v = len(text) % 3
        pixel = img[x, y]

        if v == 0:
            r = (pixel[0]//10)*10+5
            g = pixel[1]
            b = pixel[2]
        elif v == 1:
            r = pixel[0]+self._correction[pixel[0] % 10][int(text[3*i])]
            g = (pixel[1]//10)*10+5
            b = pixel[2]
        elif v == 2:
            r = pixel[0]+self._correction[pixel[0] % 10][int(text[3*i])]
            g = pixel[1]+self._correction[pixel[1] % 10][int(text[3*i+1])]
            b = (pixel[2]//10)*10+5

        if alpha:
            img[x, y] = (r, g, b, pixel[3])
        else:
            img[x, y] = (r, g, b, 255)
        newI = Image.fromarray((array(img_raw, dtype=uint8)))
        newI.save(outImgPath, format="PNG")

    # Function to extract data from image
    def eject(self, imgPath, key, toDecode=True):
        img_raw = Image.open(os.path.abspath(imgPath))
        img = img_raw.load()

        img_width = img_raw.size[0]
        img_height = img_raw.size[1]

        raw_text = ""
        bytes_value = b""

        to_break = False

        for i in range(img_height):
            if to_break:
                break
            for j in range(img_width):
                pixel = img[j, i]
                raw_text = "".join([raw_text, "".join(
                    map(lambda x: str(x % 10 % 4) if x % 10 != 5 else "5", pixel))])

                if len(raw_text) >= 4:
                    block = raw_text[:4]
                    raw_text = raw_text[4:]
                    try:
                        decimal_value = self._sd[block]
                    except KeyError:
                        to_break = True
                        break
                    hex_value_str = str(hex(decimal_value))[2:]
                    hex_value_str = "".join(["0", hex_value_str]) if len(
                        hex_value_str) == 1 else hex_value_str
                    bytes_value = b"".join(
                        [bytes_value, bytes.fromhex(hex_value_str)])

                if to_break:
                    break
        bytes_value = self._decrypt_data(key, bytes_value)
        return bytes_value.decode() if toDecode else bytes_value
